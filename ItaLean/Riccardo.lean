import Mathlib

/-!
# Number Theory in Mathlib


In this talk we discuss the implementation of number theory concepts in Mathlib, focusing on
algebraic number theory.

We will cover the following topics:
1. Number fields, their rings of integers and the units group
2. Factorization of ideals, the class group
3. A bit of modular forms and elliptic curves
-/

/- Let's declare a number field `K` -/

variable (K : Type*) [Field K] [NumberField K]

#print NumberField

#synth (Algebra â„š K)

section

/- Assume `CharZero K` if you want to work with a possible infinite extension of `â„š`, and *not*
`Algebra â„š K`.  -/

variable (L : Type*) [Field L] [Algebra â„š L] [FiniteDimensional â„š L]

example : NumberField L := by
  sorry -- This is annoying unfortunately (if you are interested we can discuss this later)

end

example (x y : K) : (x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2 := by
  ring

example (x : K) (hx : x â‰  0) : x/x = 1 := by
  field_simp

example (x y z : K) (hz : z â‰  0) : (x + y) * zâ»Â¹ * (z / (zâ»Â¹)^(-1 : â„¤)) = y/z + x/z := by
  field_simp
  ring

example (x y : K) (hy : y â‰  0) : x / y * y = x := by
  exact div_mul_cancelâ‚€ x hy

example (x y : K) (h : x ^ 3 + 3 * x ^ 2 * y + 4 * x * y ^ 2 + y ^ 3 â‰  x * y ^ 2) :
    (x ^ 2 - y ^ 2) / (x + y) = x - y := by
  grind

/- The ring of integers is denoted `ğ“ K` (you need `open NumberField`) -/

open NumberField

#check ğ“ K

#synth (CommRing (ğ“ K))

/- It is defined as the type given by elements `x : K` such that `IsIntegral â„¤ x`.

We also have a predicate `IsAlgebraic`, but most of the library uses `IsIntegral`.

Beware that `ğ“ K` is *not* a subset of `K`, but there is a *coercion*. -/

variable (x : ğ“ K) (y : K)

#check (x + y)

example (a b : ğ“ K) : (â†‘(a + b) : K) = (a : K) + (b : K) := by
  norm_cast

example (a : ğ“ K) (ha : a â‰  0) : (a : K) * (a : K)â»Â¹ = 1 := by
  refine mul_inv_cancelâ‚€ ?_ --found by `apply?`
  exact_mod_cast ha

/- The units of `ğ“ K` (and of any other multiplicative monoid) are denoted `(ğ“ K)Ë£`  -/

#check (ğ“ K)Ë£

#synth (Group (ğ“ K)Ë£)

/- There is also a *predicate* `IsUnit`, saying that `u : ğ“ K` is a unit.  -/

variable (u : ğ“ K) (v : (ğ“ K)Ë£) (hu : IsUnit u)

#check IsUnit u

#check hu.unit

#check v.isUnit

/- Again terms of type `(ğ“ K)Ë£` are *not* of type `ğ“ K`.
So there are now *various* coercions `(ğ“ K)Ë£ â†’ ğ“ K â†’ K`.

Can you prove the following without suffering too much?
 -/

example (u v : (ğ“ K)Ë£) : (u / v : ğ“ K) + 1 = (u : K) / ((v : ğ“ K) : K) + u / u:= by
  sorry

/- Trace and norm -/

#check Algebra.trace

#check Algebra.norm

/- We know that the trace/norm of an integral element is integral, but it's better to use
`Algebra.intTrace` and `Algebra.intNorm` -/

#check Algebra.intTrace â„¤ (ğ“ K)

#check Algebra.intNorm â„¤ (ğ“ K)

/- Note that `â„¤` is *not* `ğ“ â„š`, in the sense that these two types are not equal (we of course have
the isomorphism). If you need to prove theorems about the trace/norm it is important to use the
carateristic predicate `IsIntegralClosure`.

We indeed also have `RingOfIntegers.norm`, that should probably be removed. -/

example (K L : Type*) [Field K] [Field L] [Algebra K L] [NumberField K] [NumberField L] :
    Algebra.intNorm (ğ“ K) (ğ“ L) = RingOfIntegers.norm K := by
  ext
  apply Algebra.algebraMap_intNorm

section

/- As an example, this is the usual `AKLB`-setup -/

variable (A K L B : Type*) [CommRing A] [CommRing B] [Field K] [Field L]
  [Algebra A K] [Algebra B L] [IsFractionRing A K] [IsFractionRing B L]
  [Algebra A B] [Algebra K L] [Algebra A L] [IsScalarTower A K L] [IsScalarTower A B L]
  [IsIntegrallyClosed A] [IsIntegralClosure B A L]

end

/- We also have the norm of an ideal, in various forms -/

#check Ideal.relNorm
#check Ideal.absNorm

/- Working with ideals, note that the zero ideal and the whole ring are denoted `âŠ¥` and `âŠ¤`
respectively. -/

#check (âŠ¥ : Ideal (ğ“ K))
#check (âŠ¤ : Ideal (ğ“ K))

/- Mathlib knows that `ğ“ K` is a Dedekind domain. -/

#check IsDedekindDomain

#synth (IsDedekindDomain (ğ“ K))

/- One can add and multiply ideals as usual. -/

#synth (CommSemiring (Ideal (ğ“ K)))

example (I J : Ideal (ğ“ K)) : (I + J) ^ 3 = I ^ 3 + 3 * I ^ 2 * J + 3 * I * J ^ 2 + J ^ 3 := by
  ring

#synth (UniqueFactorizationMonoid (Ideal (ğ“ K)))

/- Intersection and (ideal generated by the) union are denoted `âŠ“` and `âŠ”` respectively. -/

open NoZeroDivisors

/- Mathlib knows various facts about the ideals and the units of `ğ“ K`. -/

/- Dedekind-Kummer theorem. -/
#check Ideal.primesOverSpanEquivMonicFactorsMod

/- Finiteness of the class group. -/
#synth Finite (ClassGroup (ğ“ K))

/- Existence of an ideal in each class with norm bounded by Minkowski bound. -/
#check exists_ideal_in_class_of_norm_le

/- Sum of ramification indices times inertia degrees equals degree of the field extension. -/
#check Ideal.sum_ramification_inertia

/- Dirichlet's unit theorem. -/
#check Units.exist_unique_eq_mul_prod

/- Hermite-Minkowski Theorem. A nontrivial number field has discriminant greater than `2`. -/
#check NumberField.abs_discr_gt_two

/- Hermite Theorem. Let `N be an integer. There are only finitely many number fields (in some fixed
extension of `â„š`) of discriminant bounded by `N`. -/
#check NumberField.finite_of_discr_bdd

/- How can *you* contribute?

* Take your favorite number theoretic object and try to compute some invariant explicitly! For example
the decomposition of an ideal, ring of integers, class group etc
* Results about cyclotomic fields: in particular we are missing the theory of *real* cyclotomic fields
  (let's prove FLT for `n < 37`!)
* The LeanBridge project by Chris Birkbeck

  -/
